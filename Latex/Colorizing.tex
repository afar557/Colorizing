\documentclass{article}

\setlength{\headsep}{0.75 in}
\setlength{\parindent}{0 in}
\setlength{\parskip}{0.1 in}

%=====================================================
% Add PACKAGES Here (You typically would not need to):
%=====================================================

\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amsthm}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{float}
%=====================================================
% Ignore This Part (But Do NOT Delete It:)
%=====================================================

\theoremstyle{definition}
\newtheorem{problem}{Problem}
\newtheorem*{fun}{Fun with Algorithms}
\newtheorem*{challenge}{Challenge Yourself}
\def\fline{\rule{0.75\linewidth}{0.5pt}}
\newcommand{\finishline}{\vspace{-15pt}\begin{center}\fline\end{center}}
\newtheorem*{solution*}{Solution}
\newenvironment{solution}{\begin{solution*}}{{\finishline} \end{solution*}}
\newcommand{\grade}[1]{\hfill{\textbf{($\mathbf{#1}$ points)}}}
\newcommand{\thisdate}{\today}
\newcommand{\thissemester}{\textbf{Rutgers: Spring 2021}}
\newcommand{\thiscourse}{CS 440: Introduction to Artificial Intelligence} 
\newcommand{\thishomework}{Number} 
\newcommand{\thisname}{Name} 

\newcommand{\thisheading}{
   \noindent
   \begin{center}
   \framebox{
      \vbox{\vspace{2mm}
    \hbox to 6.28in { \textbf{\thiscourse \hfill \thissemester} }
       \vspace{4mm}
       \hbox to 6.28in { {\Large \hfill Project \#\thishomework \hfill} }
       \vspace{2mm}
         \hbox to 6.28in { { \hfill \thisdate \hfill} }
       \vspace{2mm}
       \hbox to 6.28in { \emph{Names: \thisname \hfill }}
      \vspace{2mm}}
      }
   \end{center}
   \bigskip
}

%=====================================================
% Some useful MACROS (you can define your own in the same exact way also)
%=====================================================


\newcommand{\ceil}[1]{{\left\lceil{#1}\right\rceil}}
\newcommand{\floor}[1]{{\left\lfloor{#1}\right\rfloor}}
\newcommand{\prob}[1]{\Pr\paren{#1}}
\newcommand{\expect}[1]{\Exp\bracket{#1}}
\newcommand{\var}[1]{\textnormal{Var}\bracket{#1}}
\newcommand{\set}[1]{\ensuremath{\left\{ #1 \right\}}}
\newcommand{\poly}{\mbox{\rm poly}}


%=====================================================
% Fill Out This Part With Your Own Information:
%=====================================================


\renewcommand{\thishomework}{4: Colorizing} %Homework number
\renewcommand{\thisname}{Aamna Farooq (af704), Nada Elshamaa(nhe12), and Asma Makhdoom(aam355)} % Your name
 \graphicspath{ {./images/} }

\begin{document}

\thisheading

\textbf{\Large The Basic Coloring Agent} \\
 How good is the final result? How could you measure the quality of the final result? Is it numerically satisfying, if not visually? \\
 
 The final result seems pretty good visually considering that it is only based off a few representative colors. The basic agent is built by choosing 5 representative colors using Euclidean distance and k-means clustering. \\\\
 We start off by choosing 5 random points on the graph and using k-means and the Euclidean distance based on color until we get more accurate 5 color points that accurately represent the colors of our data, as much as 5 colors possibly could. \\\\
 Using these 5 representative colors we recolor the left side of the image. We recolor each pixel using the color that is the smallest Euclidean distance in RGB values from a representative color. To recolor the right side of the picture we take a look at the right and left side of the gray image. We store every possible patch from the left hand side. As we go through the right side of the gray image, we get a 3x3 patch from the right side and compare it to a sample of a thousand of the left gray image's patches to find the 6 most similar patches in terms of Euclidean distance. \\\\
 Once we have located the 6 most similar patches, we use these patches to see if there is a majority recurring color in the middle pixels of these 6 patches. If there is a majority recurring color, we recolor the middle pixel of our current right patch to that color. If there is no majority then we set the color of the middle pixel of the patch on the right side to the color of the middle pixel of the most similar patch. \\\\
 The quality of the final result can be measured by comparing the Euclidean distances between the color we computed and the actual color value in the picture to get an idea of the accuracy of the program. \\\
 There are abnormalities in our image, such as pixelation near the edges of figures but as per our conversation with the Professor in office hours we were reassured this is a normal irregularity and not a point of concern with our image. The image is numerically satisfying because each color is based on our Euclidean color distance formula which ensures that we are picking the closest color possible to the actual color in the image. Therefore we feel the image is numerically and visually satisfying. 
  
 Bonus: Instead of doing a 5-nearest neighbor based color selection, what is the best number of representative colors to pick for your data? How did you arrive at that number? Justify yourself and be thorough. \\\\
 The best number of representative colors to pick for our data would be 10 colors. We arrived at this number through trial and error where we felt the integrity of the initial image was still preserved and that it was producing the best detailed image. With higher numbers we felt that the result was not far enough visually that it would warrant increasing the number of representative colors. 

\textbf{\Large The Improved Agent} \\
	\textbf{Specifications}
	    Including description of input space, output space, model space, error / loss function, and learning algorithm 
	    \begin{solution} \hfill \\
        
        \end{solution}\\\\
    
    \textbf{Parameters}
        How did you choose the parameters (structure, weights, any decisions that needed to be made) for your model? 
        \begin{solution} \hfill \\
    
        \end{solution}\\\\
        
    \textbf{Pre-processing}
        Any pre-processing of the input of output data that you used.
        \begin{solution} \hfill \\
        We pre-processed the input data by normalizing all the RGB values to be between 0 and 1 instead of between 0 and 255. This was important so that the value of alpha would not need to be too inflated and we would be able to reach a desirable result earlier. This was also important in ensuring the output values of the color were more distinct from one another and to ensure the RGB values were not close to one another.\\\\
        We also pre-processed the data by converting the image into gray-scale using the equation provided: \\\\
        Gray(r, g, b) = 0.21r + 0.72g + 0.07b \\\\
        so that we could train the data using the gray-scale of the image. \\\\
        We also split the image into two halves so that we can use the left side of the image to train our weights using the neural network. We then use the right side of the image to recolor the image using the weights we finalized from the training of the data. 
        \end{solution}\\\\
        
    \textbf{Training}
        How did you handle training your model? How did you avoid overfitting? 
        \begin{solution} \hfill \\
    
        \end{solution}\\\\
        
    \textbf{Evaluation}
        An evaluation of the quality of your model compared to the basic agent. How can you quantify and qualify the differences between their performance? How can you make sure that the comparison is 'fair'? 
        \begin{solution} \hfill \\
    
        \end{solution}\\\\
        
    \textbf{Improvements}
        How might you improve your model with sufficient time, energy, and resources?
        \begin{solution} \hfill \\
    
        \end{solution}\\\\
\smallskip

\textbf{\Large Bonus} \\
    Why is a linear model a bad idea? 
    \begin{solution} \hfill \\
    
    \end{solution}\\
    
    Research a ML framework like scikit-learn or tensorflow, and build a solution to this problem using this framework that beats your improved agent.
    \begin{solution} \hfill \\
    
    \end{solution}\\

\smallskip   

\textbf{Work Distribution}
\\
The work is our own and not copied or taken from any other students. 
\\\\
To work on this project we would meet up over video calls daily and discuss problems and our solutions. One person would then screen share and code while the others would contribute and also assist in coding using the request remote control feature in zoom. We would alternate in screen sharing and upload to git for version control. 
\\\\
The report was done similarly. We each took on a plot and a question to complete on our own. We then met to complete the rest as a group over video call. 
\\
$Asma$ $Makhdoom:$ 
\\
$Aamna$ $Farooq:$ 
\\
$Nada$ $Elshamaa:$ 
\\
\smallskip

\end{document}